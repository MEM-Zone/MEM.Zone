## DNS Server Vulnerability (CVE-2020-1350) Workaround

Implements the workaround for the CVE-2020-1350 wormable exploit.
A POC is already available on github: https://github.com/ZephrFish/CVE-2020-1350/blob/master/exploit.sh

## Tree

```bash
.
+-- CB - DNS Server Vulnerability (CVE-2020-1350).cab (MEMCM Configuration Baseline)
+-- Get-CVE-2020-1350_Compliance.ps1
+-- Set-TcpReceivePacketSize.ps1
```

## Google Meet Webhook

You can send remediation data to a google meet webhook if you edit the remediation script $URI parameter.
I don't know why you would want it, DCs usually do not have internet access.

## Installation

Just download the [CB - DNS Server Vulnerability (CVE-2020-1350).cab](https://github.com/SCCM-Zone/sccm-zone.com/raw/master/Compliance/DNS%20Server%20Vulnerability%20(CVE-2020-1350)/CB%20-%20DNS%20Server%20Vulnerability%20(CVE-2020-1350).cab) file to your site server and import it within the Configuration Item/Baseline node via the `Import Configuration Data` right click menu.
There is no need to target a specific collection since this workaround will only apply on servers that have the DNS service installed.

## DNS Servers CMPivot Query

```kusto
Service
| where (Name == 'DNS')
```

## DNS Servers WQL Query

```WQL
SELECT SMS_R_SYSTEM.ResourceID
    ,SMS_R_SYSTEM.ResourceType
    ,SMS_R_SYSTEM.Name
    ,SMS_R_SYSTEM.SMSUniqueIdentifier
    ,SMS_R_SYSTEM.ResourceDomainORWorkgroup
    ,SMS_R_SYSTEM.Client
FROM SMS_R_System
    INNER JOIN SMS_G_System_SERVICE ON SMS_G_System_SERVICE.ResourceId = SMS_R_System.ResourceId
WHERE SMS_G_System_SERVICE.Name = "DNS"
```

## Detection

```PowerShell
<#
.SYNOPSIS
    !! DISCOVERY SCRIPT !!
    Gets compliance CVE-2020-1350 status.
.DESCRIPTION
    Gets compliance CVE-2020-1350 status by checking if DNS service is present and TcpReceivePacketSize = 0xFF00.
.NOTES
    Created by Ioan Popovici
.LINK
    https://SCCM.Zone/
.LINK
    https://SCCM.Zone/GIT
.LINK
    https://SCCM.Zone/ISSUES
#>

Begin {
    ## Variable declaration
    [string]$Path = 'HKLM:\SYSTEM\CurrentControlSet\Services\DNS\Parameters'
    [string]$Value = '0xFF00'
    [bool]$ShouldProcess = If (Get-Service -Name 'DNS' -ErrorAction 'SilentlyContinue') { $true } Else { $false }
    [string]$Result = 'Compliant'
    $LastError = $null
}
Process {
    Try {
        If ($ShouldProcess) {
            [string]$KeyValue = '0x{0:x}' -f $(Get-ItemProperty -Path $Path -ErrorAction 'SilentlyContinue').TcpReceivePacketSize
            If ($KeyValue -ne $Value) { $Result = 'Non-Compliant' }
        }
    }
    Catch { $LastError = $($Error[0].Exception) }
    Finally {
        If ($LastError) { Write-Output -InputObject $LastError }
        Else { Write-Output -InputObject $Result }
    }
}
```

## Remediation

```PowerShell
<#
.SYNOPSIS
    !! DISCOVERY SCRIPT !!
    Sets TcpReceivePacketSize value.
.DESCRIPTION
    Sets TcpReceivePacketSize value to '0xFF00' and sends a message to a google meet channel.
.NOTES
    Created by Ioan Popovici
.LINK
    https://SCCM.Zone/
.LINK
    https://SCCM.Zone/GIT
.LINK
    https://SCCM.Zone/ISSUES
#>

##*=============================================
##* FUNCTION LISTINGS
##*=============================================
#region FunctionListings

#region New-GHCTextMessage
Function New-GHCTextMessage {
    [CmdletBinding()]
    Param (
        # Text Message
        [Parameter(Mandatory)]
        [string]
        $Message
    )

    Begin {
    }

    Process {
        $TextMessage = @{'text' = $message}
        $TextMessage
    }

    End {
    }
}
#endregion

#region Function Send-GHCWebhookMessage
Function Send-GHCWebhookMessage {
    [CmdletBinding()]
    Param (
        # uri
        [Parameter(Mandatory=$true)]
        [string]
        $URI,
        # Message
        [Parameter(Mandatory)]
        [hashtable]
        $Message
    )

    Begin {
    }

    Process {
        $JSON = ConvertTo-Json $Message -Depth 50
        $JSON

        Invoke-WebRequest -UseBasicParsing -Uri $URI -Method POST -Headers @{"Content-Type" = 'Application/json; charset=UTF-8'} -Body $JSON
    }

    End {
    }
}
#endregion

#endregion
##*=============================================
##* END FUNCTION LISTINGS
##*=============================================

##*=============================================
##* SCRIPT BODY
##*=============================================
#region ScriptBody

## Variable Declaration
[string]$URI = ''
[datetime]$currentDateTime = Get-Date
[string]$envComputerNameFQDN = ([Net.Dns]::GetHostEntry('localhost')).HostName
[psobject]$envOS = Get-WmiObject -Class 'Win32_OperatingSystem' -ErrorAction 'SilentlyContinue'
[string]$envOSName = $envOS.Caption.Trim()
[string]$envOSVersion = $envOS.Version
[string]$Path = 'HKLM:\SYSTEM\CurrentControlSet\Services\DNS\Parameters'
[string]$Name = 'TcpReceivePacketSize'
[string]$Value = '0xFF00'
$LastError = $null

Try {
    [string]$KeyValue = '0x{0:x}' -f $(Get-ItemProperty -Path $Path -ErrorAction 'SilentlyContinue').$Name
    If ($KeyValue -ne $Value) {
        Set-ItemProperty -Path $Path -Name $Name -Value $Value -Type 'DWord' -Force -ErrorAction 'Stop'
        Restart-Service -Name 'DNS' -Force -ErrorAction 'Stop'
    }
}
Catch { $LastError = $Error[0].Exception }
Finally {
    If ($LastError) {
        Write-Output -InputObject $LastError
        $WebhookMessage = New-GHCTextMessage -Message "$currentDateTime - $envComputerNameFQDN - $envOSName ($envOSVersion) - $LastError"
    }
    Else {
        Write-Output -InputObject 'Remediated'
        $WebhookMessage = New-GHCTextMessage -Message "$currentDateTime - $envComputerNameFQDN - $envOSName ($envOSVersion) - Remediated"
    }
    If ($URI) { Send-GHCWebhookMessage -Message $WebhookMessage -URI $URI -ErrorAction 'SilentlyContinue' | Out-Null }
}

#endregion
##*=============================================
##* END SCRIPT BODY
##*=============================================
```

## Disclaimer

I've implemented this in production but as with anything, I am not responsible if this breaks anything.
It's up to you to test it properly.
